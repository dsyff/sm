================================================================================
           INSTRUMENT CREATION GUIDE - Best Practices
================================================================================

OVERVIEW
--------
The instrument system uses a layered architecture:
  - instrumentInterface      : Abstract base class for physical instruments
  - virtualInstrumentInterface : Base class for software-only computed channels
  - instrumentRack           : Manages multiple instruments and batch operations


================================================================================
1. PHYSICAL INSTRUMENT CLASSES
================================================================================

BASIC STRUCTURE
---------------
classdef instrument_YourInstrument < instrumentInterface
    
    properties (Access = private)
        % Private class variables (cached values, state, etc.)
    end

    methods
        %% Constructor
        function obj = instrument_YourInstrument(address)
            obj@instrumentInterface();
            
            % Establish communication
            handle = visadev(address);  % or tcpclient, serialport, etc.
            
            obj.address = address;
            obj.communicationHandle = handle;
            
            % Register channels
            obj.addChannel("V_source", setTolerances = 1e-3);
            obj.addChannel("XY", 2, setTolerances = [1e-3; 1e-3]);
        end
        
        %% Destructor
        function delete(obj)
            delete(obj.communicationHandle);
        end
    end
    
    methods (Access = ?instrumentInterface)
        % Required and optional method implementations here
    end
end


CHANNEL REGISTRATION
--------------------
Use addChannel in the constructor:

  % Scalar channel (default size = 1)
  obj.addChannel("channelName", setTolerances = 1e-3);

  % Vector channel (size = N)
  obj.addChannel("XY", 2, setTolerances = [1e-3; 1e-3]);
  obj.addChannel("spectrum", 1024, setTolerances = ones(1024, 1) * 1e-6);

Rules:
  - setTolerances must be a column vector matching channel size
  - If omitted, setTolerances defaults to 1E-6 * ones(channelSize, 1)
  - Channel names must be unique within the instrument
  - Only NUMERIC values are allowed - non-numeric data use class methods
  - setTolerances is only meaningful for SETTABLE channels that use the default
    setCheckChannelHelper (which compares the readback value against setTolerances).
    For read-only channels (not implemented in setWriteChannelHelper), setTolerances
    is unused and including it is misleading. Prefer omitting setTolerances for
    read-only channels.
  - Prefer SI units wherever convenient. If a non-SI unit is more practical,
    make the unit explicit in the channel name (common pattern: suffix).
    Example: the SI unit for plane angle is radians ("rad"), but degrees are
    often more convenient for user-facing motion. Use a name like
    "position_deg" (or "position_rad" if you use radians).


================================================================================
2. REQUIRED METHODS (MUST IMPLEMENT)
================================================================================

getWriteChannelHelper(obj, channelIndex)
----------------------------------------
Sends the query command to the instrument WITHOUT reading the response.

  function getWriteChannelHelper(obj, channelIndex)
      handle = obj.communicationHandle;
      switch channelIndex
          case 1  % "V_source"
              writeline(handle, "MEAS:VOLT?");
          case 2  % "XY"
              writeline(handle, "MEAS:XY?");
      end
  end

WHY SEPARATED? The instrumentRack sends all getWrite commands first, then
reads responses. This minimizes wait time since instruments settle in parallel.


getReadChannelHelper(obj, channelIndex)
---------------------------------------
Reads the response from the instrument. Called AFTER getWriteChannelHelper.

  function getValues = getReadChannelHelper(obj, channelIndex)
      handle = obj.communicationHandle;
      switch channelIndex
          case 1  % "V_source" - scalar
              response = readline(handle);
              getValues = str2double(strip(response));
          case 2  % "XY" - vector of size 2
              response = readline(handle);
              parts = split(strip(response), ",");
              getValues = [str2double(parts(1)); str2double(parts(2))];
      end
  end

Rules:
  - Return values as COLUMN VECTORS (system warns on row vectors)
  - Vector length must match the declared channel size


================================================================================
3. OPTIONAL METHODS (Override as Needed)
================================================================================

setWriteChannelHelper(obj, channelIndex, setValues)
---------------------------------------------------
Sends set commands to instrument. Default throws error (channel not settable).

  function setWriteChannelHelper(obj, channelIndex, setValues)
      handle = obj.communicationHandle;
      switch channelIndex
          case 1  % "V_source" - scalar
              writeline(handle, sprintf("VOLT %g", setValues));
          case 2  % "XY" - vector
              writeline(handle, sprintf("POS %g,%g", setValues(1), setValues(2)));
          otherwise
              % Delegate to parent for unsupported channels (throws error)
              setWriteChannelHelper@instrumentInterface(obj, channelIndex, setValues);
      end
  end

GUARANTEES from the framework:
  - setValues is already validated as a column vector of correct size
  - setValues contains no NaN values
  - No redundant size checks needed in your implementation
  - setValues is already a double (and already column-oriented), so redundant
    type/shape conversions like double(setValues(1)) or setValues(:) are not
    needed in helper overrides unless a specific instrument API demands a
    different numeric type for I/O.


setCheckChannelHelper(obj, channelIndex, channelLastSetValues)
--------------------------------------------------------------
Verifies set values have been reached. Default compares getChannel result
against setTolerances. Override only for special verification:

  function TF = setCheckChannelHelper(obj, channelIndex, channelLastSetValues)
      handle = obj.communicationHandle;
      writeline(handle, "STAT:SETTLED?");
      TF = str2double(readline(handle)) == 1;
  end


flush(obj)
----------
Clears the communication buffer. Override for instruments with buffered I/O:

  function flush(obj)
      flush(obj.communicationHandle);
  end


================================================================================
4. VIRTUAL INSTRUMENT CLASSES
================================================================================

For computed/derived channels that depend on other channels:

classdef virtualInstrument_resistance < virtualInstrumentInterface
    
    methods
        function obj = virtualInstrument_resistance(masterRack)
            obj@virtualInstrumentInterface("virtual_resistance", masterRack);
            obj.addChannel("R", setTolerances = 1e-6);
        end
    end
    
    methods (Access = ?instrumentInterface)
        function getValues = getReadChannelHelper(obj, channelIndex)
            rack = obj.getMasterRack();
            V = rack.rackGet("voltage");
            I = rack.rackGet("current");
            getValues = V / I;
        end
        
        function setWriteChannelHelper(obj, channelIndex, setValues)
            % Optional: implement if virtual channel is settable
            rack = obj.getMasterRack();
            I = rack.rackGet("current");
            rack.rackSet("voltage", setValues * I);
        end
    end
end

KEY DIFFERENCES from physical instruments:
  - Inherit from virtualInstrumentInterface
  - Constructor takes masterRack instead of address
  - getWriteChannelHelper is sealed (does nothing)
  - Use obj.getMasterRack() to access other channels
  - requireSetCheck is automatically set to false


================================================================================
5. CONFIGURABLE PROPERTIES
================================================================================

Inherited properties you can modify:

  Property          Default       Description
  ---------------   -----------   ------------------------------------------
  setTimeout        1 minute      Max wait time for set operations
  setInterval       2 seconds     Polling interval during set verification
  requireSetCheck   true          Whether to verify set values reached target

Example:
  obj.setTimeout = minutes(5);      % For slow-settling instruments
  obj.setInterval = seconds(0.5);   % For fast instruments
  obj.requireSetCheck = false;      % Skip verification (use with caution)


================================================================================
6. ADDING INSTRUMENTS TO THE RACK
================================================================================

NAMING CONVENTIONS (from demo.m)
--------------------------------
  Handle variable:    handle_<InstrumentType>_<ID>
                      Examples: handle_K2450_A, handle_SR830_1, handle_Montana2

  Instrument name:    Short identifier, often matching type
                      Examples: "K2450_A", "SR830_1", "strain", "MFLI"

  Channel name:       Descriptive, indicates physical quantity
                      Examples: "V_bg", "I_tg", "T", "B", "XTheta", "Cp"


TYPICAL SETUP PATTERN
---------------------
  % 1. Create instrument handle
  handle_K2450_A = instrument_K2450(gpibAddress(K2450_A_GPIB, adaptorIndex));
  handle_K2450_A.requireSetCheck = false;

  % 2. Configure instrument via direct commands
  h = handle_K2450_A.communicationHandle;
  writeline(h, ":sense:current:range 1e-7");
  writeline(h, "source:voltage:Ilimit 1e-7");
  writeline(h, ":source:voltage:range 20");
  writeline(h, "NPLcycles 0.2");
  writeline(h, ":OUTP ON");
  pause(2);

  % 3. Add to rack
  rack.addInstrument(handle_K2450_A, "K2450_A");

  % 4. Add channels with optional parameters:
  %    rack.addChannel(instName, chanName, friendlyName, rampRate, rampThresh, softMin, softMax)
  rack.addChannel("K2450_A", "V_source", "V_bg", 1, 0.5, -10, 10);
  rack.addChannel("K2450_A", "I_measure", "I_bg");
  rack.addChannel("K2450_A", "VI", "VI_bg");


CHANNEL PARAMETER REFERENCE
---------------------------
  rampRate      : V/s (or units/s) - rate of change during ramping
  rampThreshold : Skip ramping if delta is below this value
  softMin       : Software-enforced minimum limit
  softMax       : Software-enforced maximum limit

Example with all parameters:
  rack.addChannel("K2450_A", "V_source", "V_bg", 1, 0.5, -10, 10);
                  ^instName  ^chanName  ^friendly ^rate ^thresh ^min ^max

Example without limits:
  rack.addChannel("SR830_1", "sensitivity", "Ixx_Sens");


VIRTUAL INSTRUMENT SETUP
------------------------
  handle_virtual_del_V = virtualInstrument_del_V("virtual_delta", rack, ...
      vGetChannelName = "V_WSe2", vSetChannelName = "V_tg");
  rack.addInstrument(handle_virtual_del_V, "virtual_delta");
  rack.addChannel("virtual_delta", "del_V", "del_V", [], [], -10, 10);


================================================================================
7. COMMON PATTERNS & TIPS
================================================================================

USE SWITCH-CASE FOR CHANNEL DISPATCH
------------------------------------
  switch channelIndex
      case 1
          % channel 1 logic
      case 2
          % channel 2 logic
  end


HANDLE SCPI INSTRUMENTS CONSISTENTLY
------------------------------------
  function getWriteChannelHelper(obj, channelIndex)
      queries = ["MEAS:VOLT?", "MEAS:CURR?", "MEAS:RES?"];
      writeline(obj.communicationHandle, queries(channelIndex));
  end


CACHE EXPENSIVE COMPUTATIONS
----------------------------
  properties (Access = private)
      calibrationData
  end

  methods
      function obj = instrument_Spectrometer(address)
          obj.calibrationData = obj.loadCalibration();
      end
  end


AVOID COMMON MISTAKES
---------------------
  X  Don't validate setValues size - the framework already does this
  X  Don't extract scalars from setValues - treat all channels uniformly
  X  Don't return row vectors from getReadChannelHelper
  X  Don't add non-numeric channels - use class methods instead

  OK  Return column vectors
  OK  Use setTolerances appropriate for your instrument's precision
  OK  Implement flush() for instruments with buffered communication


================================================================================
8. FILE NAMING CONVENTION
================================================================================

  instrument_<InstrumentName>.m          % Physical instruments
  virtualInstrument_<Purpose>.m          % Virtual instruments

Examples:
  instrument_K2450.m
  instrument_SR830.m
  instrument_Montana2.m
  virtualInstrument_resistance.m
  virtualInstrument_hysteresis.m
  virtualInstrument_nE.m


================================================================================
END OF GUIDE
================================================================================

