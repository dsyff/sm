SMBRIDGE GUI ARCHITECTURE (SM 1.5)
=================================

Overview
--------
The smbridge layer adapts the new sm2 instrumentRack system to the legacy SM GUI
workflow. It keeps smdata/smscan/smaux compatible while routing I/O through the
instrumentRack and new smget_new/smset_new helpers.

Key files
---------
- code/smbridge/smready.m
  Entry point after rack setup. Creates smguiBridge, initializes smdata, and
  launches both GUIs (smgui_small_new + sm).

- code/smbridge/smguiBridge.m
  Builds legacy smdata from instrumentRack. Expands vector channels into scalar
  names for plotting compatibility. Exposes helper getters for vector/scalar
  channel name lists and channel sizes.

- code/smbridge/smgui_small_new.m
  Scan editor (single smscan). Handles loop definition, set/get channels, and
  plot selection. Uses vector channel names for acquisition, and expands to
  scalar names for plotting.

- code/smbridge/sm_new_Callback.m + code/smbridge/sm.m
  Queue GUI and available scans library. Manages smaux.scans (library) and
  smaux.smq (queue), launches smgui_small_new for editing, and runs smrun_new.

- code/smbridge/smrun_new.m
  Runtime scan engine. Uses smchanlookup_new to expand vector channel names
  into scalar indices, then calls instrumentRack.rackSet/rackGet directly.

- code/smbridge/smchanlookup_new.m
  Resolves channel names into smdata channel indices. When vector_name=true,
  vector channel names are expanded into scalar names (e.g. XY -> XY_1, XY_2).

Vector channels (what the GUI stores vs plots)
----------------------------------------------
- Acquisition uses vector channel names.
  - smscan.loops(i).getchan stores vector names (e.g. "XY").
  - smscan.loops(i).setchan stores scalar names (vector setting is not allowed).
- Plotting uses expanded scalar names.
  - smguiBridge expands vector channels into scalar channels in smdata.channels.
  - smgui_small_new builds plot lists by converting vector names to scalar names
    (e.g. "XY_1", "XY_2") using bridge.getChannelSize.

Scan GUI vs Queue GUI
---------------------
- Scan GUI (smgui_small_new)
  - Edits a single smscan: loop ranges, set/get channels, constants, plots.
  - Stores plot selections in smscan.disp (1D/2D entries).
  - Uses shared state helpers for data path, PPT, and run number.
- Queue/Main GUI (sm + sm_new_Callback)
  - Manages smaux.scans (available scans) and smaux.smq (queue).
  - Launches smgui_small_new for editing, and smrun_new for execution.

Paths and shared state
----------------------
- Shared state helpers under code/smbridge/shared:
  - data/: smdatapath* (data directory state)
  - ppt/:  smppt* (ppt log state)
  - run/:  smrun* (run number state)
- smrun_new resolves relative PPT paths using bridge.experimentRootPath when set.
- Data folder and PPT file are enforced under bridge.experimentRootPath; GUI
  selections change the subfolder name (data) or filename (ppt), not the root.

Menu items not yet implemented
------------------------------
- Scan GUI menu:
  - Open Rack / Save Rack / Edit Rack are placeholders (show Not Implemented).

Notes
-----
- smget_new/smset_new expect rack-friendly channel names (channelFriendlyNames).
- Vector channels are expanded only for plotting and smdata compatibility; they
  are not settable as vectors.

smrun_new execution flow
------------------------
- smrun_new takes a scan struct (or uses global smscan) and runs it against
  instrumentRackGlobal.
- For set/get channels, it resolves vector names into scalar indices via
  smchanlookup_new(..., true), then builds scalar channel name lists from
  smdata.channels for saving and display.
- Set operations call instrumentRackGlobal.rackSet with the original
  channelFriendlyNames and values.
- Get operations call instrumentRackGlobal.rackGet with the original
  channelFriendlyNames and store returned numeric values.
- During run, display selections are mapped to data slices; PNG/PPT export is
  handled at the end of the run.

Saved data structure
--------------------
Each scan writes a .mat file containing:
- data : 1xN cell array of numeric arrays, one per scalar get channel.
  - N = total number of scalar get channels across all loops (after vector expansion).
  - Order matches concatenation of loops in scan.loops (loop 1 entries first).
    - Example: if loop 2 (outer) has channel A and loop 1 (inner) has channel B,
      then data{1} corresponds to B (loop 1) and data{2} corresponds to A (loop 2).
  - data{k} is sized to the loop dimensions for that channel:
    - dimensions correspond to loops from outer to inner.
    - for a 1-loop scan, size is [npoints 1].
    - for a 2-loop scan, size is [npoints_outer, npoints_inner].
  - Vector channels are expanded into separate scalar entries (e.g. XY_1, XY_2).
- data channel names:
  - Stored in scan.loops(*).getchan as scalar channel name strings.
  - Use scan.loops to rebuild the ordered list that aligns with data{k}.
- scan : scan struct saved alongside data.
  - scan.loops(*).getchan : cell array of scalar channel name strings (expanded).
  - scan.loops(*).setchan : cell array of scalar channel name strings (expanded).
  - scan.disp : display selections with fields {loop, channel, dim} referencing
    indices into the scalar channel list used for plotting.
  - scan.consts : preserved; set constants applied at run start.
