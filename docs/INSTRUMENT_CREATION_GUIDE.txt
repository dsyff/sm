================================================================================
           INSTRUMENT CREATION GUIDE - Best Practices
================================================================================

OVERVIEW
--------
The instrument system uses a layered architecture:
  - instrumentInterface      : Abstract base class for physical instruments
  - virtualInstrumentInterface : Base class for software-only computed channels
  - instrumentRack           : Manages multiple instruments and batch operations

CANONICAL USER SETUP SCRIPT
---------------------------
There are two canonical setup styles:
  - `demos/demo.m` (RECOMMENDED): recipe-based workflow. The rack is built on a
    worker “engine” process via `instrumentRackRecipe`.
  - `tests/demo_nE.m` (DEBUG/LEGACY, git-ignored): explicit rack-on-client
    workflow. Useful for hardware bring-up and single-threaded debugging.

If you create/edit an instrument class or change channel names/sizes, update the
relevant demo(s) accordingly (and keep `docs/INSTRUMENT_SETUP_GUIDE.txt`
consistent).


================================================================================
1. PHYSICAL INSTRUMENT CLASSES
================================================================================

BASIC STRUCTURE
---------------
classdef instrument_YourInstrument < instrumentInterface
    
    properties (Access = private)
        % Private class variables (cached values, state, etc.)
    end

    methods
        %% Constructor
        function obj = instrument_YourInstrument(address)
            obj@instrumentInterface();
            
            % Establish communication
            handle = visadev(address);  % or tcpclient, serialport, etc.
            
            obj.address = address;
            obj.communicationHandle = handle;
            
            % Register channels
            obj.addChannel("V_source", setTolerances = 1e-3);
            obj.addChannel("XY", 2, setTolerances = [1e-3; 1e-3]);
        end
        
        %% Destructor
        function delete(obj)
            delete(obj.communicationHandle);
        end
    end
    
    methods (Access = ?instrumentInterface)
        % Required and optional method implementations here
    end
end


CHANNEL REGISTRATION
--------------------
Use addChannel in the constructor:

  % Scalar channel (default size = 1)
  obj.addChannel("channelName", setTolerances = 1e-3);

  % Vector channel (size = N)
  obj.addChannel("XY", 2, setTolerances = [1e-3; 1e-3]);
  obj.addChannel("spectrum", 1024, setTolerances = ones(1024, 1) * 1e-6);

Rules:
  - setTolerances must be a column vector matching channel size
  - If omitted, setTolerances defaults to 1E-6 * ones(channelSize, 1)
  - Channel names must be unique within the instrument
  - Only NUMERIC values are allowed - non-numeric data use class methods
  - setTolerances is only meaningful for SETTABLE channels that use the default
    setCheckChannelHelper (which compares the readback value against setTolerances).
    If obj.requireSetCheck = false, then setCheckChannelHelper is never used and
    setTolerances is ignored (so including setTolerances is misleading).
    For read-only channels (not implemented in setWriteChannelHelper), setTolerances
    is unused and including it is misleading. Prefer omitting setTolerances for
    read-only channels.
  - Prefer SI units wherever convenient. If a non-SI unit is more practical,
    make the unit explicit in the channel name (common pattern: suffix).
    Example: the SI unit for plane angle is radians ("rad"), but degrees are
    often more convenient for user-facing motion. Use a name like
    "position_deg" (or "position_rad" if you use radians).


================================================================================
2. REQUIRED METHODS (MUST IMPLEMENT)
================================================================================

getWriteChannelHelper(obj, channelIndex)
----------------------------------------
Sends the query command to the instrument WITHOUT reading the response.

  function getWriteChannelHelper(obj, channelIndex)
      handle = obj.communicationHandle;
      switch channelIndex
          case 1  % "V_source"
              writeline(handle, "MEAS:VOLT?");
          case 2  % "XY"
              writeline(handle, "MEAS:XY?");
      end
  end

WHY SEPARATED? The instrumentRack sends all getWrite commands first, then
reads responses. This minimizes wait time since instruments settle in parallel.
Also, both get-write and set-write calls pass through a shared write pacing
gate in `instrumentInterface` (`writeCommandInterval`), so bus pacing can be
configured per instrument without adding ad-hoc pauses in helpers.
For Keithley setups, note that consecutive get/set commands can be fast while
the read phase after a get query is often much slower (around 0.5 s depending
on NPLC/averaging/auto-zero/readback settings).


getReadChannelHelper(obj, channelIndex)
---------------------------------------
Reads the response from the instrument. Called AFTER getWriteChannelHelper.

  function getValues = getReadChannelHelper(obj, channelIndex)
      handle = obj.communicationHandle;
      switch channelIndex
          case 1  % "V_source" - scalar
              response = readline(handle);
              getValues = str2double(strip(response));
          case 2  % "XY" - vector of size 2
              response = readline(handle);
              parts = split(strip(response), ",");
              getValues = [str2double(parts(1)); str2double(parts(2))];
      end
  end

Rules:
  - Return values as COLUMN VECTORS (system warns on row vectors)
  - Vector length must match the declared channel size


================================================================================
3. OPTIONAL METHODS (Override as Needed)
================================================================================

setWriteChannelHelper(obj, channelIndex, setValues)
---------------------------------------------------
Sends set commands to instrument. Default throws error (channel not settable).

  function setWriteChannelHelper(obj, channelIndex, setValues)
      handle = obj.communicationHandle;
      switch channelIndex
          case 1  % "V_source" - scalar
              writeline(handle, sprintf("VOLT %g", setValues));
          case 2  % "XY" - vector
              writeline(handle, sprintf("POS %g,%g", setValues(1), setValues(2)));
          otherwise
              % Delegate to parent for unsupported channels (throws error)
              setWriteChannelHelper@instrumentInterface(obj, channelIndex, setValues);
      end
  end

GUARANTEES from the framework:
  - setValues is already validated as a column vector of correct size
  - setValues contains no NaN values
  - No redundant size checks needed in your implementation
  - setValues is already a double (and already column-oriented), so redundant
    type/shape conversions like double(setValues(1)) or setValues(:) are not
    needed in helper overrides unless a specific instrument API demands a
    different numeric type for I/O.


setCheckChannelHelper(obj, channelIndex, channelLastSetValues)
--------------------------------------------------------------
Verifies set values have been reached. Default compares getChannel result
against setTolerances. Override only for special verification:

  function TF = setCheckChannelHelper(obj, channelIndex, channelLastSetValues)
      handle = obj.communicationHandle;
      writeline(handle, "STAT:SETTLED?");
      TF = str2double(readline(handle)) == 1;
  end


flush(obj)
----------
Clears the communication buffer. Override for instruments with buffered I/O:

  function flush(obj)
      flush(obj.communicationHandle);
  end

Recommendation:
  - Implement flush when your instrument uses buffered I/O.
  - Do NOT call flush repeatedly inside get/set helpers unless the instrument
    behaves poorly and this is absolutely necessary. Unexplained buffer content
    is usually from interrupted reads/scans, and frequent flushing wastes time.
  - The rack/main scripts already flush all instruments on init and before each
    scan (see smready and measurementEngine). instrumentRack.addInstrument also flushes
    once per instrument during registration.


================================================================================
4. VIRTUAL INSTRUMENT CLASSES
================================================================================

For computed/derived channels that depend on other channels:

classdef virtualInstrument_resistance < virtualInstrumentInterface
    
    methods
        function obj = virtualInstrument_resistance(masterRack)
            obj@virtualInstrumentInterface("virtual_resistance", masterRack);
            obj.addChannel("R", setTolerances = 1e-6);
        end
    end
    
    methods (Access = ?instrumentInterface)
        function getValues = getReadChannelHelper(obj, channelIndex)
            rack = obj.getMasterRack();
            V = rack.rackGet("voltage");
            I = rack.rackGet("current");
            getValues = V / I;
        end
        
        function setWriteChannelHelper(obj, channelIndex, setValues)
            % Optional: implement if virtual channel is settable
            rack = obj.getMasterRack();
            I = rack.rackGet("current");
            rack.rackSet("voltage", setValues * I);
        end
    end
end

KEY DIFFERENCES from physical instruments:
  - Inherit from virtualInstrumentInterface
  - Constructor takes masterRack instead of address
  - getWriteChannelHelper is sealed (does nothing)
  - Use obj.getMasterRack() to access other channels
  - requireSetCheck is automatically set to false


================================================================================
5. CONFIGURABLE PROPERTIES
================================================================================

Inherited properties you can modify:

  Property          Default       Description
  ---------------   -----------   ------------------------------------------
  setTimeout        1 minute      Max wait time for set operations
  setInterval       2 seconds     Polling interval during set verification
  requireSetCheck   true          Whether to verify set values reached target
  writeCommandInterval 0 seconds  Min spacing between write commands (getWrite/setWrite)
  numWorkersRequired 0            Additional pool workers this instrument needs

Example:
  obj.setTimeout = minutes(5);      % For slow-settling instruments
  obj.setInterval = seconds(0.5);   % For fast instruments
  obj.requireSetCheck = false;      % Skip verification (use with caution)
  obj.writeCommandInterval = seconds(0.2); % For slow command buses (example: some GPIB setups)

Notes on write pacing:
  - `writeCommandInterval` is enforced before each instrument write command
    issued by framework paths (`getWriteChannel...` / `setWriteChannel...`).
  - Default is `seconds(0)`.
  - For instruments that lose/ignore commands when written too quickly,
    set this in the constructor.
  - Automatic bus-type-based delays are not applied by default.
  - If needed, set pacing manually for that specific instrument.


================================================================================
6. WORKER ENGINE + INSTRUMENT WORKERS (RECIPE MODE)
================================================================================

In recipe mode, instrument constructors run on the engine worker. Workers cannot
spawn workers directly, so any background instrument worker(s) must be started
on the client.

For status/diagnostic output in worker-capable code, always use:
  experimentContext.print(...)
instead of direct fprintf/disp. experimentContext.print routes worker messages
to the client terminal via the shared DataQueue, while local calls print
directly.

Two pieces are required:
  1) Pool sizing (EXPLICIT in the recipe):
     - When adding an instrument to an `instrumentRackRecipe`, pass the reserved
       name-value `numeWorkersRequested = N` so the engine can allocate
       (1 engine worker + sum(numeWorkersRequested)) processes.

     Example:
       recipe.addInstrument("h", "instrument_myInst", "myInst", ..., numeWorkersRequested = 2);

  2) Spawning the worker(s) from engine-worker code:
     - Call `requestWorkerSpawn(...)` from the worker to request the client to start a
       `parfeval` task on the shared pool.

     Example (from worker-side code):
       requestWorkerSpawn("myInst", @myWorkerMain, 0, arg1, arg2);


================================================================================
7. ADDING INSTRUMENTS TO THE RACK
================================================================================

NAMING CONVENTIONS (from demo.m)
--------------------------------
  Handle variable:    handle_<InstrumentType>_<ID>
                      Examples: handle_K2450_A, handle_SR830_1, handle_Montana2

  Instrument name:    Short identifier, often matching type
                      Examples: "K2450_A", "SR830_1", "strain", "MFLI"

  Channel name:       Descriptive, indicates physical quantity
                      Examples: "V_bg", "I_tg", "T", "B", "XTheta", "Cp"


TYPICAL SETUP PATTERN
---------------------
  % 1. Create instrument handle
  handle_K2450_A = instrument_K2450(gpibAddress(K2450_A_GPIB, adaptorIndex));
  handle_K2450_A.requireSetCheck = false;

  % 2. Configure instrument via direct commands
  h = handle_K2450_A.communicationHandle;
  writeline(h, ":SOURce:VOLTage:READ:BACK OFF");
  writeline(h, ":SENSe:CURRent:AZERo:STATe OFF");
  writeline(h, ":SOURce:DELay 0");
  writeline(h, ":SENSe:CURRent:RANGe 1e-7");
  writeline(h, ":SOURce:VOLTage:ILIMit 1e-7");
  writeline(h, ":SOURce:VOLTage:RANGe 20");
  writeline(h, ":SENSe:CURRent:NPLCycles 0.5");
  writeline(h, ":OUTPut ON");
  pause(2);

  % 3. Add to rack
  rack.addInstrument(handle_K2450_A, "K2450_A");

  % 4. Add channels with optional parameters:
  %    rack.addChannel(instName, chanName, friendlyName, rampRate, rampThresh, softMin, softMax)
  rack.addChannel("K2450_A", "V_source", "V_bg", 1, 0.5, -10, 10);
  rack.addChannel("K2450_A", "I_measure", "I_bg");
  rack.addChannel("K2450_A", "VI", "VI_bg");


CHANNEL PARAMETER REFERENCE
---------------------------
  rampRate      : V/s (or units/s) - rate of change during ramping
  rampThreshold : Skip ramping if delta is below this value
  softMin       : Software-enforced minimum limit
  softMax       : Software-enforced maximum limit
  Note: softMin/softMax are enforced only by instrumentRack (smset/rackSet).
        Direct instrument.setChannel calls do not apply software limits.

Example with all parameters:
  rack.addChannel("K2450_A", "V_source", "V_bg", 1, 0.5, -10, 10);
                  ^instName  ^chanName  ^friendly ^rate ^thresh ^min ^max

Example without limits:
  rack.addChannel("SR830_1", "sensitivity", "Ixx_Sens");


VIRTUAL INSTRUMENT SETUP
------------------------
  handle_virtual_del_V = virtualInstrument_del_V("virtual_delta", rack, ...
      vGetChannelName = "V_WSe2", vSetChannelName = "V_tg");
  rack.addInstrument(handle_virtual_del_V, "virtual_delta");
  rack.addChannel("virtual_delta", "del_V", "del_V", [], [], -10, 10);


================================================================================
8. COMMON PATTERNS & TIPS
================================================================================

USE SWITCH-CASE FOR CHANNEL DISPATCH
------------------------------------
  switch channelIndex
      case 1
          % channel 1 logic
      case 2
          % channel 2 logic
  end

Performance note:
  - In hot helper paths (`getWriteChannelHelper`, `getReadChannelHelper`,
    `setWriteChannelHelper`), prefer dispatching directly on `channelIndex`.
  - Avoid resolving `obj.channelTable.channels(channelIndex)` unless you need
    a name for diagnostics/errors; repeated string lookup/parsing is slower.


HANDLE SCPI INSTRUMENTS CONSISTENTLY
------------------------------------
  function getWriteChannelHelper(obj, channelIndex)
      queries = ["MEAS:VOLT?", "MEAS:CURR?", "MEAS:RES?"];
      writeline(obj.communicationHandle, queries(channelIndex));
  end


CACHE EXPENSIVE COMPUTATIONS
----------------------------
  properties (Access = private)
      calibrationData
  end

  methods
      function obj = instrument_Spectrometer(address)
          obj.calibrationData = obj.loadCalibration();
      end
  end


KEEP VENDOR SDK/API FILES WITH THE CLASS + USE RUNTIME ABSOLUTE PATHS
--------------------------------------------------------------------
If an instrument requires vendor SDK files (e.g. C header files, DLLs, .NET
assemblies, config files), keep them inside the instrument class folder for
organization, e.g.:
  - code/instruments/@instrument_AndorSpectrometer/atspectrograph.h
  - code/instruments/@instrument_CS165MU/dlls/*.dll

Do NOT rely on the current working directory or relative paths. Instead, build
absolute paths at runtime by locating the class file, then deriving its folder:

  % Preferred (instance methods): robust to renames/inheritance
  classFile = which(class(obj));
  instDir = fileparts(classFile);

  % Fallback (static helpers where you don't have obj):
  classFile = which("instrument_YourInstrument");
  instDir = fileparts(classFile);

  headerPath = fullfile(instDir, "vendor_header.h");
  dllDir = fullfile(instDir, "dlls");

Always validate the path exists (isfile/isfolder) and throw a clear error that
includes the resolved path. This makes instruments robust to different launch
contexts (different startup folders, different path configurations, etc.).


AVOID COMMON MISTAKES
---------------------
  X  Don't validate setValues size - the framework already does this
  X  Don't extract scalars from setValues - treat all channels uniformly
  X  Don't return row vectors from getReadChannelHelper
  X  Don't add non-numeric channels - use class methods instead

  OK  Return column vectors
  OK  Use setTolerances appropriate for your instrument's precision
  OK  Implement flush() for instruments with buffered communication


================================================================================
9. FILE NAMING CONVENTION
================================================================================

  instrument_<InstrumentName>.m          % Physical instruments
  virtualInstrument_<Purpose>.m          % Virtual instruments

Examples:
  instrument_K2450.m
  instrument_SR830.m
  instrument_Montana2.m
  virtualInstrument_resistance.m
  virtualInstrument_hysteresis.m
  virtualInstrument_nE.m


================================================================================
END OF GUIDE
================================================================================

