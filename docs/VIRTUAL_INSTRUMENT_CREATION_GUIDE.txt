================================================================================
      VIRTUAL INSTRUMENT CREATION GUIDE (SM 1.5 / sm2)
================================================================================

OVERVIEW
--------
Virtual instruments are software-only instruments that:
  - Inherit from `virtualInstrumentInterface` (which inherits `instrumentInterface`)
  - Are constructed with a reference to the master `instrumentRack`
  - Register channels via `addChannel(...)`
  - Implement `getReadChannelHelper` (required) and optionally `setWriteChannelHelper`

Use virtual instruments for derived channels (e.g. n/E from gate voltages) or
for composite controls that map a user “set” onto multiple physical channels.


================================================================================
1. MINIMAL TEMPLATE
================================================================================

classdef virtualInstrument_example < virtualInstrumentInterface
    methods
        function obj = virtualInstrument_example(address, masterRack)
            arguments
                address (1, 1) string
                masterRack (1, 1) instrumentRack
            end

            obj@virtualInstrumentInterface(address, masterRack);
            obj.addChannel("derived_value");
        end
    end

    methods (Access = ?instrumentInterface)
        function getValues = getReadChannelHelper(obj, channelIndex)
            switch channelIndex
                case 1
                    rack = obj.getMasterRack();
                    v = rack.rackGet("some_physical_channel");
                    getValues = v(1);
            end
        end
    end
end

Key points:
  - The constructor MUST call `virtualInstrumentInterface(address, masterRack)`.
  - Return numeric data with the correct length for the declared channel size.
  - Virtual instruments do not participate in the physical getWrite/getRead
    scheduler; reads are synchronous.


================================================================================
2. SETTABLE VIRTUAL CHANNELS
================================================================================

To make a virtual channel settable, override `setWriteChannelHelper` and map the
requested value onto one or more physical channels using the master rack.

Pattern:
  - Keep a small amount of internal state (the last requested virtual value)
  - Compute physical targets
  - Write the physical targets via `rack.rackSetWrite(...)` (or `rack.rackSet(...)`)

See `code/instruments/virtualInstrument_nE.m` for a concrete example.

Current `virtualInstrument_nE` channel names:
  - `n`
  - `E`
  - `nE_within_bounds`
  - `skipOutOfBounds` (settable 0/1; when 1, out-of-bounds n/E requests are skipped)

Note: older scripts may still reference `skipSettingOutOfBoundsValues`; use
`skipOutOfBounds` instead.


================================================================================
3. RECIPE MODE (WORKER ENGINE)
================================================================================

When using `instrumentRackRecipe` (engine-worker rack construction):
  - Virtual instruments are constructed on the engine worker.
  - The engine passes the worker’s master rack into the constructor.

To add a virtual instrument to a recipe:
  - Use `recipe.addVirtualInstrument(handleVar, className, friendlyName, ...)`
  - Ensure your constructor signature is `(address, masterRack, NameValueArgs...)`.


================================================================================
4. COMMON PITFALLS
================================================================================

  - Do not rely on globals: always use `obj.getMasterRack()`.
  - Avoid recursion: do not read/write your own virtual channel(s) via the rack.
  - Keep reads fast: virtual reads run inline with the measurement loop.


================================================================================
END OF GUIDE
================================================================================
